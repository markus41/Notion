# C4 Component Diagram - .NET Orchestration Service

## Overview
This diagram reveals the internal component structure of the .NET Orchestration Service, showing how workflow coordination, state management, and agent communication components collaborate to establish reliable, scalable workflow execution patterns.

**Best for:** Engineers implementing or extending the orchestration layer who need to understand component responsibilities and interaction patterns.

## Component Architecture (C4 Level 3)

```mermaid
C4Component
    title Orchestration Service Components (C4 Level 3 - .NET 8)

    Container_Boundary(orchestrationService, "Orchestration API (.NET 8)") {
        Component(workflowController, "Workflow Controller", "ASP.NET Core Controller", "REST API endpoints for workflow CRUD operations. Validates requests and delegates to orchestrator.")

        Component(metaAgentOrchestrator, "MetaAgent Orchestrator", "C# Class", "Coordinates workflow execution, manages agent handoffs, and orchestrates parallel task execution with DAG-based scheduling.")

        Component(workflowExecutor, "Workflow Executor", "C# Class", "Implements execution patterns: Sequential, Parallel, Iterative, and Dynamic. Manages task scheduling and dependency resolution.")

        Component(stateManager, "State Manager", "C# Class", "Manages Cosmos DB state persistence with optimistic concurrency. Implements checkpoint creation and recovery logic.")

        Component(pythonAgentClient, "Python Agent Client", "HTTP Client", "Resilient HTTP client for Python service communication. Implements retry, circuit breaker, and timeout patterns.")

        Component(metaAgentHub, "MetaAgent SignalR Hub", "SignalR Hub", "Real-time communication hub broadcasting workflow events to connected clients. Manages subscription lifecycle.")

        Component(qualityGateValidator, "Quality Gate Validator", "C# Class", "Validates task outputs against configured quality gates and success criteria. Supports custom validation rules.")

        Component(contextManager, "Context Manager", "C# Class", "Manages shared workflow context with deduplication. Implements LRU caching and context versioning.")

        Component(checkpointManager, "Checkpoint Manager", "C# Class", "Creates, stores, and retrieves workflow checkpoints. Implements automatic, manual, and failure checkpointing strategies.")

        Component(recoveryService, "Recovery Service", "Background Service", "Monitors failed workflows and initiates recovery from checkpoints. Implements saga pattern for compensating actions.")

        Component(telemetryProvider, "Telemetry Provider", "OpenTelemetry", "Distributed tracing and metrics collection. Implements W3C Trace Context propagation.")
    }

    ContainerDb_Ext(cosmosDB, "Cosmos DB", "Azure Cosmos DB", "Workflow state, checkpoints, metadata")
    ContainerDb_Ext(redisCache, "Redis Cache", "Azure Cache for Redis", "Context cache, distributed locks")
    Container_Ext(pythonService, "Python Agent Service", "FastAPI", "Agent execution runtime")
    Container_Ext(signalRService, "SignalR Service", "Azure SignalR", "Real-time messaging infrastructure")
    System_Ext(appInsights, "Application Insights", "Telemetry and monitoring")

    Rel(workflowController, metaAgentOrchestrator, "Delegates workflow execution", "Method call")
    Rel(metaAgentOrchestrator, workflowExecutor, "Executes workflow pattern", "Method call")
    Rel(metaAgentOrchestrator, contextManager, "Manages shared context", "Method call")
    Rel(workflowExecutor, pythonAgentClient, "Executes agent tasks", "HTTP/JSON")
    Rel(workflowExecutor, stateManager, "Persists state", "Method call")
    Rel(workflowExecutor, checkpointManager, "Creates checkpoints", "Method call")
    Rel(workflowExecutor, qualityGateValidator, "Validates outputs", "Method call")
    Rel(metaAgentOrchestrator, metaAgentHub, "Publishes events", "SignalR SDK")
    Rel(recoveryService, stateManager, "Retrieves failed workflows", "Method call")
    Rel(recoveryService, checkpointManager, "Loads checkpoints", "Method call")
    Rel(recoveryService, metaAgentOrchestrator, "Resumes execution", "Method call")

    Rel(stateManager, cosmosDB, "Reads/writes state", "Cosmos SDK")
    Rel(checkpointManager, cosmosDB, "Stores checkpoints", "Cosmos SDK")
    Rel(contextManager, redisCache, "Caches context", "StackExchange.Redis")
    Rel(pythonAgentClient, pythonService, "Invokes agents", "HTTP")
    Rel(metaAgentHub, signalRService, "Broadcasts events", "SignalR SDK")

    Rel(workflowController, telemetryProvider, "Sends traces", "OpenTelemetry")
    Rel(metaAgentOrchestrator, telemetryProvider, "Sends metrics", "OpenTelemetry")
    Rel(telemetryProvider, appInsights, "Exports telemetry", "OTLP")

    UpdateRelStyle(metaAgentOrchestrator, workflowExecutor, $textColor="blue", $lineColor="blue")
    UpdateRelStyle(workflowExecutor, pythonAgentClient, $textColor="green", $lineColor="green")
    UpdateRelStyle(metaAgentHub, signalRService, $textColor="purple", $lineColor="purple")
```

## Component Responsibilities

### Workflow Controller

**Purpose:** Establish REST API surface for workflow management operations

**Responsibilities:**
- Validate incoming HTTP requests using FluentValidation
- Authenticate requests via Azure AD JWT bearer tokens
- Authorize access based on user roles and workflow ownership
- Delegate workflow operations to MetaAgentOrchestrator
- Transform domain models to DTOs for API responses
- Handle HTTP-specific concerns (status codes, headers, CORS)

**API Endpoints:**
```csharp
[HttpPost("api/workflows")]
public async Task<ActionResult<WorkflowResponse>> CreateWorkflow(
    CreateWorkflowRequest request,
    CancellationToken cancellationToken)

[HttpGet("api/workflows/{id}")]
public async Task<ActionResult<WorkflowResponse>> GetWorkflow(
    string id,
    CancellationToken cancellationToken)

[HttpGet("api/workflows")]
public async Task<ActionResult<PagedResponse<WorkflowResponse>>> ListWorkflows(
    [FromQuery] WorkflowQuery query,
    CancellationToken cancellationToken)

[HttpDelete("api/workflows/{id}")]
public async Task<IActionResult> CancelWorkflow(
    string id,
    CancellationToken cancellationToken)

[HttpPost("api/workflows/{id}/resume")]
public async Task<ActionResult<WorkflowResponse>> ResumeWorkflow(
    string id,
    [FromQuery] string? checkpointId,
    CancellationToken cancellationToken)
```

**Dependencies:**
- `IMetaAgentOrchestrator` for workflow orchestration
- `IValidator<T>` for request validation
- `ILogger<WorkflowController>` for structured logging

---

### MetaAgent Orchestrator

**Purpose:** Coordinate end-to-end workflow execution with agent handoffs and state management

**Responsibilities:**
- Determine workflow execution pattern (Sequential, Parallel, Iterative, Dynamic)
- Coordinate multi-agent handoffs with context passing
- Manage workflow lifecycle (start, pause, resume, cancel)
- Publish real-time events via SignalR hub
- Handle errors and trigger recovery mechanisms
- Track workflow metrics (duration, task count, cost)

**Key Methods:**
```csharp
public async Task<WorkflowResult> ExecuteWorkflowAsync(
    WorkflowDefinition definition,
    Dictionary<string, object> initialContext,
    CancellationToken cancellationToken)

public async Task<WorkflowResult> ResumeWorkflowAsync(
    string workflowId,
    string? checkpointId,
    CancellationToken cancellationToken)

public async Task CancelWorkflowAsync(
    string workflowId,
    CancellationToken cancellationToken)

private async Task PublishWorkflowEventAsync(
    string workflowId,
    WorkflowEvent workflowEvent)
```

**Patterns Implemented:**
- **Strategy Pattern:** Different execution strategies per workflow pattern
- **Observer Pattern:** Event publishing to SignalR subscribers
- **Template Method:** Common workflow lifecycle with pattern-specific execution

---

### Workflow Executor

**Purpose:** Implement workflow execution patterns with dependency resolution and parallel scheduling

**Responsibilities:**
- Build directed acyclic graph (DAG) from task dependencies
- Perform topological sort to identify execution levels
- Schedule parallel task execution within levels
- Manage task dependencies and data passing
- Coordinate with PythonAgentClient for task execution
- Create checkpoints after task completion
- Handle task failures and retry logic

**Execution Patterns:**

**Sequential Pattern:**
```csharp
public async Task<WorkflowResult> ExecuteSequentialAsync(
    WorkflowDefinition workflow,
    WorkflowContext context,
    CancellationToken cancellationToken)
{
    foreach (var task in workflow.Tasks)
    {
        var result = await ExecuteTaskAsync(task, context, cancellationToken);
        context.SetTaskResult(task.Id, result);
        await _checkpointManager.CreateCheckpointAsync(workflow.Id, context);
    }
    return BuildWorkflowResult(context);
}
```

**Parallel Pattern:**
```csharp
public async Task<WorkflowResult> ExecuteParallelAsync(
    WorkflowDefinition workflow,
    WorkflowContext context,
    CancellationToken cancellationToken)
{
    var dag = BuildDependencyGraph(workflow.Tasks);
    var levels = dag.TopologicalSort();

    foreach (var level in levels)
    {
        var tasks = level.Select(taskId =>
            ExecuteTaskAsync(workflow.Tasks[taskId], context, cancellationToken));

        var results = await Task.WhenAll(tasks);

        foreach (var (taskId, result) in results)
        {
            context.SetTaskResult(taskId, result);
        }

        await _checkpointManager.CreateCheckpointAsync(workflow.Id, context);
    }

    return BuildWorkflowResult(context);
}
```

**Iterative Pattern:**
```csharp
public async Task<WorkflowResult> ExecuteIterativeAsync(
    WorkflowDefinition workflow,
    WorkflowContext context,
    CancellationToken cancellationToken)
{
    var maxIterations = workflow.Configuration.MaxIterations ?? 10;
    var iteration = 0;

    while (iteration < maxIterations)
    {
        var builderResult = await ExecuteTaskAsync(
            workflow.BuilderTask, context, cancellationToken);

        var validationResult = await ExecuteTaskAsync(
            workflow.ValidatorTask, context, cancellationToken);

        if (validationResult.IsValid)
        {
            context.SetTaskResult("final", builderResult);
            break;
        }

        context.AddFeedback(validationResult.Feedback);
        iteration++;
    }

    return BuildWorkflowResult(context);
}
```

**Dynamic Pattern:**
```csharp
public async Task<WorkflowResult> ExecuteDynamicAsync(
    WorkflowDefinition workflow,
    WorkflowContext context,
    CancellationToken cancellationToken)
{
    var currentTask = workflow.InitialTask;

    while (currentTask != null)
    {
        var result = await ExecuteTaskAsync(currentTask, context, cancellationToken);
        context.SetTaskResult(currentTask.Id, result);

        // Next task determined at runtime by agent response
        currentTask = DetermineNextTask(result, workflow);

        await _checkpointManager.CreateCheckpointAsync(workflow.Id, context);
    }

    return BuildWorkflowResult(context);
}
```

---

### State Manager

**Purpose:** Manage workflow state persistence with optimistic concurrency and recovery support

**Responsibilities:**
- Persist workflow state to Cosmos DB
- Implement optimistic concurrency using ETag validation
- Handle concurrency conflicts with retry logic
- Query workflow state with filtering and pagination
- Manage workflow lifecycle status transitions
- Implement soft-delete for workflow archival

**Key Methods:**
```csharp
public async Task<WorkflowState> SaveStateAsync(
    WorkflowState state,
    CancellationToken cancellationToken)
{
    try
    {
        var response = await _container.UpsertItemAsync(
            state,
            new PartitionKey(state.Id),
            new ItemRequestOptions { IfMatchEtag = state.ETag },
            cancellationToken);

        return response.Resource;
    }
    catch (CosmosException ex) when (ex.StatusCode == HttpStatusCode.PreconditionFailed)
    {
        // ETag mismatch - optimistic concurrency conflict
        throw new ConcurrencyException("Workflow was modified by another process", ex);
    }
}

public async Task<WorkflowState?> GetStateAsync(
    string workflowId,
    CancellationToken cancellationToken)

public async Task<PagedResult<WorkflowState>> QueryStatesAsync(
    WorkflowQuery query,
    CancellationToken cancellationToken)

public async Task DeleteStateAsync(
    string workflowId,
    CancellationToken cancellationToken)
```

**Cosmos DB Schema:**
```json
{
  "id": "wf_abc123",
  "name": "Customer Onboarding Workflow",
  "pattern": "Sequential",
  "status": "Running",
  "tasks": [
    {
      "id": "task_001",
      "agentType": "Architect",
      "status": "Completed",
      "result": {...}
    }
  ],
  "context": {
    "customerId": "cust_456",
    "region": "US-West"
  },
  "metadata": {
    "createdBy": "user@example.com",
    "createdAt": "2025-10-14T10:00:00Z",
    "updatedAt": "2025-10-14T10:05:00Z"
  },
  "_etag": "abc123xyz",
  "ttl": -1
}
```

---

### Python Agent Client

**Purpose:** Provide resilient HTTP communication with Python Agent Service

**Responsibilities:**
- Execute HTTP requests to Python service with retry and circuit breaker
- Implement exponential backoff for transient failures
- Handle timeout and cancellation gracefully
- Serialize/deserialize JSON payloads with Pydantic schemas
- Propagate distributed trace context (W3C Trace Context)
- Log request/response for debugging and audit

**Resilience Configuration:**
```csharp
public class PythonAgentClientOptions
{
    public string BaseUrl { get; set; } = "http://localhost:8000";
    public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(60);
    public int MaxRetryAttempts { get; set; } = 3;
    public TimeSpan CircuitBreakerDuration { get; set; } = TimeSpan.FromSeconds(30);
    public int CircuitBreakerThreshold { get; set; } = 5;
}
```

**Polly Policies:**
```csharp
private IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(
            retryCount: _options.MaxRetryAttempts,
            sleepDurationProvider: retryAttempt =>
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000)),
            onRetry: (outcome, timespan, retryCount, context) =>
            {
                _logger.LogWarning(
                    "Retry {RetryCount} after {Delay}ms due to {Reason}",
                    retryCount, timespan.TotalMilliseconds, outcome.Exception?.Message);
            });
}

private IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => (int)r.StatusCode >= 500)
        .Or<HttpRequestException>()
        .CircuitBreakerAsync(
            handledEventsAllowedBeforeBreaking: _options.CircuitBreakerThreshold,
            durationOfBreak: _options.CircuitBreakerDuration,
            onBreak: (outcome, duration) =>
            {
                _logger.LogError("Circuit breaker opened for {Duration}s", duration.TotalSeconds);
            },
            onReset: () =>
            {
                _logger.LogInformation("Circuit breaker reset");
            });
}
```

**Request Execution:**
```csharp
public async Task<AgentResult> ExecuteTaskAsync(
    AgentTaskRequest request,
    CancellationToken cancellationToken)
{
    var httpRequest = new HttpRequestMessage(HttpMethod.Post, "/api/agents/execute")
    {
        Content = JsonContent.Create(request)
    };

    // Propagate trace context
    var activity = Activity.Current;
    if (activity != null)
    {
        httpRequest.Headers.Add("traceparent", activity.Id);
    }

    var response = await _httpClient.SendAsync(httpRequest, cancellationToken);
    response.EnsureSuccessStatusCode();

    var result = await response.Content.ReadFromJsonAsync<AgentResult>(cancellationToken);
    return result!;
}
```

---

### MetaAgent SignalR Hub

**Purpose:** Broadcast real-time workflow events to connected web clients

**Responsibilities:**
- Manage client connections and subscriptions
- Broadcast workflow events to subscribed clients
- Implement connection authentication via JWT tokens
- Handle connection lifecycle (connect, disconnect, reconnect)
- Group clients by workflow ID for targeted broadcasting
- Throttle event publishing to prevent flooding

**Hub Methods:**
```csharp
public class MetaAgentHub : Hub
{
    public async Task SubscribeToWorkflow(string workflowId)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, workflowId);
        _logger.LogInformation(
            "Client {ConnectionId} subscribed to workflow {WorkflowId}",
            Context.ConnectionId, workflowId);
    }

    public async Task UnsubscribeFromWorkflow(string workflowId)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, workflowId);
        _logger.LogInformation(
            "Client {ConnectionId} unsubscribed from workflow {WorkflowId}",
            Context.ConnectionId, workflowId);
    }

    public override async Task OnConnectedAsync()
    {
        var userId = Context.User?.Identity?.Name;
        _logger.LogInformation("Client connected: {ConnectionId}, User: {UserId}",
            Context.ConnectionId, userId);
        await base.OnConnectedAsync();
    }

    public override async Task OnDisconnectedAsync(Exception? exception)
    {
        _logger.LogInformation("Client disconnected: {ConnectionId}", Context.ConnectionId);
        await base.OnDisconnectedAsync(exception);
    }
}
```

**Event Broadcasting:**
```csharp
public async Task PublishWorkflowStartedAsync(string workflowId, WorkflowMetadata metadata)
{
    await _hubContext.Clients.Group(workflowId).SendAsync(
        "ReceiveWorkflowStarted",
        workflowId,
        metadata);
}

public async Task PublishTaskCompletedAsync(string workflowId, string taskId, object result)
{
    await _hubContext.Clients.Group(workflowId).SendAsync(
        "ReceiveTaskCompleted",
        taskId,
        result);
}

public async Task PublishAgentThoughtAsync(string workflowId, string thought)
{
    await _hubContext.Clients.Group(workflowId).SendAsync(
        "ReceiveAgentThought",
        thought);
}
```

---

### Quality Gate Validator

**Purpose:** Validate task outputs against configured quality gates and success criteria

**Responsibilities:**
- Load validation rules from workflow configuration
- Execute validation logic against task outputs
- Support custom validators via plugin architecture
- Generate validation reports with actionable feedback
- Integrate with Iterative pattern for feedback loops

**Validation Types:**
- **Schema Validation:** JSON schema compliance
- **Business Rules:** Custom C# validation logic
- **LLM Validation:** Use AI to validate semantic correctness
- **Performance Validation:** Check execution time, token usage
- **Security Validation:** Scan for PII, credentials, malicious content

**Implementation:**
```csharp
public async Task<ValidationResult> ValidateAsync(
    object output,
    QualityGate qualityGate,
    CancellationToken cancellationToken)
{
    var validationResults = new List<ValidationError>();

    // Schema validation
    if (qualityGate.Schema != null)
    {
        var schemaErrors = ValidateSchema(output, qualityGate.Schema);
        validationResults.AddRange(schemaErrors);
    }

    // Business rules
    foreach (var rule in qualityGate.Rules)
    {
        var ruleResult = await ExecuteRuleAsync(output, rule, cancellationToken);
        if (!ruleResult.IsValid)
        {
            validationResults.Add(ruleResult.Error);
        }
    }

    // LLM validation (if configured)
    if (qualityGate.UseLLMValidation)
    {
        var llmResult = await _llmValidator.ValidateAsync(output, qualityGate.ValidationPrompt);
        if (!llmResult.IsValid)
        {
            validationResults.Add(new ValidationError(llmResult.Feedback));
        }
    }

    return new ValidationResult
    {
        IsValid = validationResults.Count == 0,
        Errors = validationResults,
        Feedback = GenerateFeedback(validationResults)
    };
}
```

---

### Context Manager

**Purpose:** Manage shared workflow context with deduplication and caching

**Responsibilities:**
- Store and retrieve context data across workflow execution
- Implement content-addressable storage using SHA-256 hashing
- Cache frequently accessed context in Redis
- Deduplicate context to reduce redundant storage
- Version context for auditing and rollback
- Evict stale context using LRU policy

**Implementation:**
```csharp
public async Task<string> StoreContextAsync(
    string workflowId,
    string key,
    object value,
    CancellationToken cancellationToken)
{
    var json = JsonSerializer.Serialize(value);
    var hash = ComputeHash(json);

    // Check if content already exists
    var existingKey = await _redis.StringGetAsync($"context:hash:{hash}");
    if (existingKey.HasValue)
    {
        _logger.LogDebug("Context deduplicated: {Hash}", hash);
        return existingKey.ToString();
    }

    // Store in Redis with TTL
    await _redis.StringSetAsync(
        $"context:{workflowId}:{key}",
        json,
        TimeSpan.FromHours(1));

    await _redis.StringSetAsync(
        $"context:hash:{hash}",
        $"{workflowId}:{key}",
        TimeSpan.FromHours(1));

    return key;
}

public async Task<T?> GetContextAsync<T>(
    string workflowId,
    string key,
    CancellationToken cancellationToken)
{
    var json = await _redis.StringGetAsync($"context:{workflowId}:{key}");
    if (!json.HasValue)
    {
        return default;
    }

    return JsonSerializer.Deserialize<T>(json.ToString());
}

private string ComputeHash(string content)
{
    using var sha256 = SHA256.Create();
    var bytes = Encoding.UTF8.GetBytes(content);
    var hash = sha256.ComputeHash(bytes);
    return Convert.ToBase64String(hash);
}
```

---

### Checkpoint Manager

**Purpose:** Create and manage workflow checkpoints for recovery and auditing

**Responsibilities:**
- Create checkpoints at strategic points (task completion, errors, manual)
- Store checkpoints in Cosmos DB with TTL (30 days)
- Backup checkpoints to Blob Storage for long-term retention
- Load checkpoints for workflow recovery
- Clean up expired checkpoints automatically
- Generate checkpoint metadata (timestamp, trigger, size)

**Checkpoint Types:**
```csharp
public enum CheckpointType
{
    Automatic,    // After each task completion
    Manual,       // User-triggered
    Failure,      // Before retry or recovery
    Paused        // Workflow paused by user
}
```

**Implementation:**
```csharp
public async Task<Checkpoint> CreateCheckpointAsync(
    string workflowId,
    WorkflowContext context,
    CheckpointType type = CheckpointType.Automatic,
    CancellationToken cancellationToken = default)
{
    var checkpoint = new Checkpoint
    {
        Id = $"cp_{Guid.NewGuid():N}",
        WorkflowId = workflowId,
        Type = type,
        State = SerializeContext(context),
        CreatedAt = DateTime.UtcNow,
        Metadata = new CheckpointMetadata
        {
            TasksCompleted = context.CompletedTasks.Count,
            TotalTasks = context.TotalTasks,
            DurationMs = context.ElapsedMilliseconds
        }
    };

    // Store in Cosmos DB with TTL
    checkpoint.Ttl = (int)TimeSpan.FromDays(30).TotalSeconds;
    await _cosmosContainer.CreateItemAsync(checkpoint, new PartitionKey(workflowId));

    // Backup to Blob Storage (async, fire-and-forget)
    _ = BackupCheckpointAsync(checkpoint, cancellationToken);

    _logger.LogInformation(
        "Checkpoint created: {CheckpointId} for workflow {WorkflowId}",
        checkpoint.Id, workflowId);

    return checkpoint;
}

public async Task<WorkflowContext> LoadCheckpointAsync(
    string workflowId,
    string? checkpointId = null,
    CancellationToken cancellationToken = default)
{
    Checkpoint checkpoint;

    if (string.IsNullOrEmpty(checkpointId))
    {
        // Load latest checkpoint
        var query = _cosmosContainer.GetItemLinqQueryable<Checkpoint>()
            .Where(c => c.WorkflowId == workflowId)
            .OrderByDescending(c => c.CreatedAt)
            .Take(1);

        checkpoint = await query.FirstOrDefaultAsync(cancellationToken);
    }
    else
    {
        checkpoint = await _cosmosContainer.ReadItemAsync<Checkpoint>(
            checkpointId,
            new PartitionKey(workflowId),
            cancellationToken: cancellationToken);
    }

    return DeserializeContext(checkpoint.State);
}
```

---

### Recovery Service

**Purpose:** Monitor failed workflows and initiate automated recovery

**Responsibilities:**
- Monitor workflow state for failures and timeouts
- Initiate recovery from checkpoints automatically
- Implement saga pattern for compensating actions
- Retry failed tasks with exponential backoff
- Send alerts for unrecoverable failures
- Track recovery metrics (success rate, duration)

**Background Service:**
```csharp
public class RecoveryService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await ScanForFailedWorkflowsAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in recovery service");
            }
        }
    }

    private async Task ScanForFailedWorkflowsAsync(CancellationToken cancellationToken)
    {
        var failedWorkflows = await _stateManager.QueryStatesAsync(
            new WorkflowQuery { Status = WorkflowStatus.Failed },
            cancellationToken);

        foreach (var workflow in failedWorkflows)
        {
            if (ShouldAttemptRecovery(workflow))
            {
                await AttemptRecoveryAsync(workflow, cancellationToken);
            }
        }
    }

    private async Task AttemptRecoveryAsync(
        WorkflowState workflow,
        CancellationToken cancellationToken)
    {
        _logger.LogInformation("Attempting recovery for workflow {WorkflowId}", workflow.Id);

        try
        {
            var checkpoint = await _checkpointManager.LoadCheckpointAsync(
                workflow.Id, null, cancellationToken);

            await _orchestrator.ResumeWorkflowAsync(
                workflow.Id, checkpoint.Id, cancellationToken);

            _logger.LogInformation("Successfully recovered workflow {WorkflowId}", workflow.Id);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to recover workflow {WorkflowId}", workflow.Id);
            await SendAlertAsync(workflow, ex);
        }
    }
}
```

---

### Telemetry Provider

**Purpose:** Collect and export distributed traces, metrics, and logs

**Responsibilities:**
- Implement OpenTelemetry instrumentation
- Propagate W3C Trace Context across services
- Collect custom metrics (workflow duration, task count, cost)
- Export telemetry to Application Insights
- Implement sampling to reduce telemetry volume
- Enrich traces with workflow metadata

**Configuration:**
```csharp
services.AddOpenTelemetry()
    .WithTracing(builder => builder
        .AddAspNetCoreInstrumentation()
        .AddHttpClientInstrumentation()
        .AddSource("AgentStudio.Orchestration")
        .AddAzureMonitorTraceExporter(options =>
        {
            options.ConnectionString = configuration["ApplicationInsights:ConnectionString"];
        }))
    .WithMetrics(builder => builder
        .AddAspNetCoreInstrumentation()
        .AddRuntimeInstrumentation()
        .AddMeter("AgentStudio.Orchestration")
        .AddAzureMonitorMetricExporter(options =>
        {
            options.ConnectionString = configuration["ApplicationInsights:ConnectionString"];
        }));
```

**Custom Metrics:**
```csharp
private readonly Counter<long> _workflowCounter = _meter.CreateCounter<long>(
    "workflows.started",
    description: "Number of workflows started");

private readonly Histogram<double> _workflowDuration = _meter.CreateHistogram<double>(
    "workflows.duration",
    unit: "ms",
    description: "Workflow execution duration");

private readonly Counter<long> _taskCounter = _meter.CreateCounter<long>(
    "tasks.executed",
    description: "Number of tasks executed");

public void RecordWorkflowStarted(string pattern)
{
    _workflowCounter.Add(1, new KeyValuePair<string, object>("pattern", pattern));
}

public void RecordWorkflowCompleted(string workflowId, double durationMs)
{
    _workflowDuration.Record(durationMs,
        new KeyValuePair<string, object>("workflow.id", workflowId));
}
```

## Component Interaction Sequence

```mermaid
sequenceDiagram
    participant Client as Web App
    participant Controller as Workflow Controller
    participant Orchestrator as MetaAgent Orchestrator
    participant Executor as Workflow Executor
    participant AgentClient as Python Agent Client
    participant State as State Manager
    participant Checkpoint as Checkpoint Manager
    participant Hub as SignalR Hub
    participant Cosmos as Cosmos DB

    Client->>Controller: POST /api/workflows
    Controller->>Orchestrator: ExecuteWorkflowAsync()
    Orchestrator->>Hub: PublishWorkflowStarted()
    Hub-->>Client: ReceiveWorkflowStarted

    Orchestrator->>Executor: ExecuteParallelAsync()
    Executor->>Executor: BuildDependencyGraph()
    Executor->>Executor: TopologicalSort()

    loop For each execution level
        par Parallel Task Execution
            Executor->>AgentClient: ExecuteTaskAsync(task1)
            AgentClient-->>Executor: AgentResult
        and
            Executor->>AgentClient: ExecuteTaskAsync(task2)
            AgentClient-->>Executor: AgentResult
        end

        Executor->>State: SaveStateAsync()
        State->>Cosmos: UpsertItemAsync()
        Cosmos-->>State: Updated state

        Executor->>Checkpoint: CreateCheckpointAsync()
        Checkpoint->>Cosmos: CreateItemAsync()
        Cosmos-->>Checkpoint: Checkpoint created

        Executor->>Hub: PublishTaskCompleted()
        Hub-->>Client: ReceiveTaskCompleted
    end

    Executor-->>Orchestrator: WorkflowResult
    Orchestrator->>Hub: PublishWorkflowCompleted()
    Hub-->>Client: ReceiveWorkflowCompleted
    Orchestrator-->>Controller: WorkflowResult
    Controller-->>Client: 200 OK (WorkflowResponse)
```

## Related Documentation

- [C4 System Context](c4-system-context.mmd) - High-level system ecosystem
- [C4 Container Diagram](c4-container.mmd) - Service-level architecture
- [Data Flow Documentation](data-flows.md) - Detailed sequence diagrams
- [ADR-008: Command Orchestration Integration](../adrs/ADR-008-command-orchestration-integration.md)
- [ADR-009: DAG-Based Orchestration](../adrs/ADR-009-dag-based-orchestration.md)
- [ADR-010: Context Manager Design](../adrs/ADR-010-context-manager-design.md)

---

**Version:** 1.0.0
**Last Updated:** 2025-10-14
**Maintained By:** Architecture Team
**Review Cycle:** Quarterly or on major architecture changes

This component architecture establishes clear separation of concerns designed to streamline development, testing, and maintenance of the orchestration layer across Agent Studio's distributed infrastructure.
